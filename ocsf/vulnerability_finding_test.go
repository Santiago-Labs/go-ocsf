package ocsf

// import (
// 	"encoding/json"
// 	"fmt"
// 	"os"
// 	"reflect"
// 	"strings"
// 	"testing"
// )

// var (
// 	partitionKeys = map[string][]string{
// 		"VulnerabilityFinding": {"EventDay"},
// 	}
// )

// func TestVulnerabilityFindingSchema(t *testing.T) {
// 	schemaData, err := os.ReadFile("test_data/schema.json")
// 	if err != nil {
// 		t.Fatalf("Failed to read test data: %v", err)
// 	}

// 	var schema map[string]interface{}

// 	err = json.Unmarshal([]byte(schemaData), &schema)
// 	if err != nil {
// 		t.Fatalf("Failed to marshal test data: %v", err)
// 	}

// 	profiles := schema["profiles"].(map[string]interface{})
// 	classes := schema["classes"].(map[string]interface{})
// 	objects := schema["objects"].(map[string]interface{})

// 	removeProfileFields(classes, profiles)
// 	removeDeprecatedFields(objects)
// 	removeDeprecatedFields(classes)
// 	removeDTFields(objects)
// 	removeDTFields(classes)

// 	vulnFindingClass := classes["vulnerability_finding"].(map[string]interface{})
// 	vulnFindingFields := vulnFindingClass["attributes"].(map[string]interface{})

// 	goSchema := reflect.TypeOf(VulnerabilityFinding{})

// 	err = schemaCompare(goSchema, vulnFindingFields, schema)
// 	if err != nil {
// 		t.Fatalf("Schema comparison failed: %v", err)
// 	}

// 	// Validate required
// }

// func schemaCompare(goSchema reflect.Type, jsonSchema map[string]interface{}, schema map[string]interface{}) error {

// 	goFieldNames := sanitizedGoFieldNames(goSchema)

// 	if len(goFieldNames) != len(jsonSchema) {
// 		for fieldName := range jsonSchema {
// 			fmt.Println(fieldName)
// 		}
// 		return fmt.Errorf("error on %s: number of fields do not match. Go: %d, JSON: %d", goSchema.Name(), len(goFieldNames), len(jsonSchema))
// 	}

// 	for _, fieldName := range goFieldNames {
// 		field, ok := goSchema.FieldByName(fieldName)
// 		if !ok {
// 			return fmt.Errorf("error on %s: field %s not found in go schema", goSchema.Name(), fieldName)
// 		}

// 		fieldTagRaw := field.Tag.Get("parquet")
// 		if fieldTagRaw == "" {
// 			return fmt.Errorf("error on %s: field %s has no parquet tag", goSchema.Name(), fieldName)
// 		}

// 		goFieldTagName := strings.Split(fieldTagRaw, ",")[0]

// 		_, ok = jsonSchema[goFieldTagName]
// 		if !ok {
// 			return fmt.Errorf("error on %s: field %s not found in json schema", goSchema.Name(), goFieldTagName)
// 		}

// 		jsonField := jsonSchema[goFieldTagName].(map[string]interface{})

// 		goType := field.Type

// 		if goType.Kind() == reflect.Slice {
// 			if jsonField["is_array"] == false {
// 				return fmt.Errorf("error on %s: field %s is not an array", goSchema.Name(), goFieldTagName)
// 			}

// 			goType = goType.Elem()
// 		}

// 		if goType.Kind() == reflect.Struct || (goType.Kind() == reflect.Ptr && goType.Elem().Kind() == reflect.Struct) {
// 			jsonObjects := schema["objects"].(map[string]interface{})

// 			// We sometimes pluralize the field name, so use the type name from the JSON schema.
// 			jsonObject, ok := jsonObjects[jsonField["type"].(string)].(map[string]interface{})
// 			if !ok {
// 				return fmt.Errorf("error on %s: field %s is not an object", goSchema.Name(), goFieldTagName)
// 			}
// 			objectAttributes := jsonObject["attributes"].(map[string]interface{})

// 			if goType.Kind() == reflect.Ptr {
// 				goType = goType.Elem()
// 			}

// 			err := schemaCompare(goType, objectAttributes, schema)
// 			if err != nil {
// 				return fmt.Errorf("error on %s: %v", goSchema.Name(), err)
// 			}
// 			continue
// 		}

// 		jsonFieldType, err := resolveOCSFType(jsonField["type"].(string), schema["types"].(map[string]interface{}))
// 		if err != nil {
// 			return fmt.Errorf("error on %s: could not resolve OCSF type: %s: %v", goSchema.Name(), jsonField["type"].(string), err)
// 		}
// 		if resolveGoType(goType) != jsonFieldType {
// 			return fmt.Errorf("error on %s: field %s type does not match. Go type: %s, JSON type: %s", goSchema.Name(), goFieldTagName, goType.String(), jsonFieldType)
// 		}

// 		// Also check if field is required

// 	}

// 	return nil
// }

// func sanitizedGoFieldNames(goSchema reflect.Type) []string {
// 	schemaPartitionKey := partitionKeys[goSchema.Name()]

// 	var fields []string
// 	for i := 0; i < goSchema.NumField(); i++ {
// 		field := goSchema.Field(i)

// 		var isPartitionKey bool
// 		for _, partitionKey := range schemaPartitionKey {
// 			if field.Name == partitionKey {
// 				isPartitionKey = true
// 				break
// 			}
// 		}

// 		if isPartitionKey {
// 			continue
// 		}

// 		fields = append(fields, field.Name)
// 	}
// 	return fields
// }

// func removeDeprecatedFields(jsonObjects map[string]interface{}) {
// 	for objectName := range jsonObjects {
// 		object := jsonObjects[objectName].(map[string]interface{})
// 		objectFields := object["attributes"].(map[string]interface{})
// 		for fieldName := range objectFields {
// 			fieldValue := objectFields[fieldName].(map[string]interface{})
// 			if fieldValue["@deprecated"] != nil {
// 				delete(objectFields, fieldName)
// 			}
// 		}
// 	}
// }

// // OCSF schema has duplicate fields for some timestamps. These fields have the suffix "_dt".
// // We only keep the "time" field.
// func removeDTFields(jsonObjects map[string]interface{}) {
// 	for objectName := range jsonObjects {
// 		object := jsonObjects[objectName].(map[string]interface{})
// 		objectFields := object["attributes"].(map[string]interface{})
// 		for fieldName := range objectFields {
// 			if strings.HasSuffix(fieldName, "_dt") {
// 				delete(objectFields, fieldName)
// 			}
// 		}
// 	}
// }

// func removeProfileFields(objects, profiles map[string]interface{}) {
// 	for objectName := range objects {
// 		object := objects[objectName].(map[string]interface{})

// 		if object["profiles"] == nil {
// 			continue
// 		}

// 		objectProfiles := object["profiles"].([]interface{})
// 		for _, objectProfileName := range objectProfiles {
// 			objectProfileName := objectProfileName.(string)
// 			profile := profiles[objectProfileName].(map[string]interface{})

// 			objectAttributes := objects[objectName].(map[string]interface{})["attributes"].(map[string]interface{})

// 			profileFields := profile["attributes"].(map[string]interface{})
// 			for profileFieldName := range profileFields {
// 				delete(objectAttributes, profileFieldName)
// 			}
// 		}
// 	}
// 	return
// }

// func resolveOCSFType(targetType string, types map[string]interface{}) (reflect.Type, error) {
// 	if types[targetType] == nil {
// 		return nil, fmt.Errorf("type %s not found", targetType)
// 	}

// 	if types[targetType].(map[string]interface{})["type"] != nil {
// 		ref := types[targetType].(map[string]interface{})["type"].(string)
// 		return resolveOCSFType(ref, types)
// 	}

// 	switch types[targetType].(map[string]interface{})["caption"].(string) {
// 	case "String":
// 		return reflect.TypeOf(""), nil
// 	case "Long":
// 		return reflect.TypeOf(int64(0)), nil
// 	case "JSON":
// 		return reflect.TypeOf(""), nil
// 	case "Integer":
// 		return reflect.TypeOf(int32(0)), nil
// 	case "Float":
// 		return reflect.TypeOf(float64(0)), nil
// 	case "Boolean":
// 		return reflect.TypeOf(false), nil
// 	default:
// 		return nil, fmt.Errorf("type %s not found", targetType)
// 	}
// }

// func resolveGoType(goType reflect.Type) reflect.Type {
// 	if goType.Kind() == reflect.Ptr {
// 		return goType.Elem()
// 	}

// 	return goType
// }
