package main

import (
	"encoding/json"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"os/exec"
	"reflect"
	"regexp"
	"sort"
	"strings"
)

var (
	partitionedTypes = make(map[string]bool)
	refTree          = make(map[string]map[string]bool)
	refStructsUsed   = make(map[string]bool)
)

func main() {
	schemaData, err := os.ReadFile("1.4.0.json")
	if err != nil {
		log.Fatalf("Failed to read test data: %v", err)
	}

	var schema map[string]interface{}

	err = json.Unmarshal([]byte(schemaData), &schema)
	if err != nil {
		log.Fatalf("Failed to marshal test data: %v", err)
	}

	profiles := schema["profiles"].(map[string]interface{})
	classes := schema["classes"].(map[string]interface{})
	objects := schema["objects"].(map[string]interface{})

	types := schema["types"].(map[string]interface{})

	removeProfileFields(classes, profiles)
	removeDeprecatedFields(objects)
	removeDeprecatedFields(classes)
	removeDTFields(objects)
	removeDTFields(classes)

	err = os.MkdirAll("../ocsf/v1_4_0", 0755)
	if err != nil {
		log.Fatalf("Failed to create directory: %v", err)
	}

	for _, class := range sortedKeys(classes) {
		className := classes[class].(map[string]interface{})["name"].(string)
		partitionedTypes[className] = true
		err := generateGoStruct(classes[class].(map[string]interface{}), objects, types)
		if err != nil {
			log.Fatalf("Failed to generate Go struct: %v", err)
		}
	}

	for _, object := range sortedKeys(objects) {
		err := generateGoStruct(objects[object].(map[string]interface{}), objects, types)
		if err != nil {
			log.Fatalf("Failed to generate Go struct: %v", err)
		}
	}

	for usedRefStruct := range refStructsUsed {
		err := generateRefStructs(objects[usedRefStruct].(map[string]interface{}))
		if err != nil {
			log.Fatalf("Failed to generate ref struct: %v", err)
		}
	}
}

func generateGoStruct(class, objects, types map[string]interface{}) error {
	classFields, ok := class["attributes"].(map[string]interface{})
	if !ok {
		return nil
	}

	sanitizedObjectCaption := sanitizeCaption(class["caption"].(string))
	className := class["name"].(string)

	fileHeader := `
// autogenerated by scripts/model_gen.go. DO NOT EDIT
package v1_4_0

import (
	"github.com/apache/arrow-go/v18/arrow"
)

`

	arrowFields := fmt.Sprintf("var %sFields = []arrow.Field{\n", sanitizedObjectCaption)
	goStruct := fmt.Sprintf("type %s struct {\n", sanitizedObjectCaption)

	if partitionedTypes[class["name"].(string)] {
		classFields["region"] = map[string]interface{}{
			"caption":     "Region",
			"description": "The region of the event. Used for partitioning.",
			"requirement": "required",
			"type":        "string_t",
		}

		classFields["account_id"] = map[string]interface{}{
			"caption":     "Account ID",
			"description": "The account ID of the event. Used for partitioning.",
			"requirement": "required",
			"type":        "string_t",
		}

	}

	for _, fieldName := range sortedKeys(classFields) {
		fieldValue := classFields[fieldName].(map[string]interface{})

		required := fieldValue["requirement"] == "required"
		rawType := fieldValue["type"].(string)

		titleSubstrings := strings.Split(fieldName, "_")
		for idx := range titleSubstrings {
			titleSubstrings[idx] = strings.ToUpper(string(titleSubstrings[idx][0])) + titleSubstrings[idx][1:]
		}

		fieldTitle := strings.Join(titleSubstrings, "")

		var fieldType string
		var arrowType string
		var isTimestamp bool
		if strings.HasSuffix(rawType, "_t") {
			if rawType == "date_t" {
				fieldType = "int32"
				arrowType = "arrow.FixedWidthTypes.Date32"
			} else if rawType == "timestamp_t" {
				fieldType = "int64"
				isTimestamp = true
				arrowType = "arrow.FixedWidthTypes.Timestamp_ms"
			} else {
				var err error
				fieldType, err = resolveOCSFType(rawType, types)
				if err != nil {
					log.Fatalf("Failed to resolve OCSF type: %v", err)
				}
				arrowType = goTypeToArrowType(fieldType)
			}
		} else {
			if rawType == "object" {
				fieldType = "string"
				arrowType = goTypeToArrowType(fieldType)
			} else {
				fieldType = sanitizeCaption(objects[rawType].(map[string]interface{})["caption"].(string))
				if refTree[sanitizedObjectCaption] == nil {
					refTree[sanitizedObjectCaption] = make(map[string]bool)
				}
				refTree[sanitizedObjectCaption][fieldType] = true

				if fieldRefTree, ok := refTree[fieldType]; ok && fieldRefTree[sanitizedObjectCaption] {
					arrowType = fmt.Sprintf("%sRefStruct", fieldType)
					fieldType = fmt.Sprintf("%sRef", fieldType)
					refStructsUsed[fieldValue["type"].(string)] = true
				} else {
					arrowType = fmt.Sprintf("%sStruct", fieldType)
				}
			}
		}

		if !required && !isTimestamp {
			fieldType = "*" + fieldType
		}

		var extraTags string
		if fieldValue["is_array"] == true {
			// A bug in go-parquet causes it to not handle slices of pointers.
			if !required {
				fieldType = strings.ReplaceAll(fieldType, "*", "")
			}
			fieldType = "[]" + fieldType
			arrowType = "arrow.ListOf(" + arrowType + ")"
			extraTags = ",list"
		}

		if isTimestamp {
			extraTags = ",timestamp_millis,timestamp(millisecond)"
		}

		goStruct += fmt.Sprintf("\n// %s: %s\n", fieldValue["caption"].(string), fieldValue["description"].(string))
		if required {
			goStruct += fmt.Sprintf("%s %s `json:\"%s\" parquet:\"%s%s\"`\n", fieldTitle, fieldType, fieldName, fieldName, extraTags)
			arrowFields += fmt.Sprintf("{Name: \"%s\", Type: %s, Nullable: false},\n", fieldName, arrowType)
		} else {
			goStruct += fmt.Sprintf("%s %s `json:\"%s,omitempty\" parquet:\"%s%s,optional\"`\n", fieldTitle, fieldType, fieldName, fieldName, extraTags)
			arrowFields += fmt.Sprintf("{Name: \"%s\", Type: %s, Nullable: true},\n", fieldName, arrowType)
		}
	}

	goStruct += "}\n"
	arrowFields += "}\n"

	arrowStruct := fmt.Sprintf("var %sStruct = arrow.StructOf(%sFields...)\n", sanitizedObjectCaption, sanitizedObjectCaption)
	arrowSchemaDec := fmt.Sprintf("var %sSchema = arrow.NewSchema(%sFields, nil)", sanitizedObjectCaption, sanitizedObjectCaption)
	arrowClassname := fmt.Sprintf("var %sClassname = \"%s\"\n", sanitizedObjectCaption, className)
	finalOutput := fileHeader + "\n" + goStruct + "\n" + arrowFields + "\n" + arrowStruct + "\n" + arrowSchemaDec + "\n" + arrowClassname

	filename := class["name"].(string) + ".go"

	err := os.WriteFile("../ocsf/v1_4_0/"+filename, []byte(finalOutput), 0644)
	if err != nil {
		return err
	}

	cmd := exec.Command("goimports", "-w", "../ocsf/v1_4_0/"+filename)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to gofmt file %s: %v", fmt.Sprintf("../ocsf/v1_4_0/%s", filename), err)
	}

	return nil
}

func generateRefStructs(class map[string]interface{}) error {
	filepath := "../ocsf/v1_4_0/" + class["name"].(string) + ".go"

	src, err := os.ReadFile(filepath)
	if err != nil {
		return err
	}
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filepath, src, 0)
	if err != nil {
		return err
	}

	sanitizedObjectCaption := sanitizeCaption(class["caption"].(string))

	var arrowFields, goStruct string
	ast.Inspect(file, func(n ast.Node) bool {
		gd, ok := n.(*ast.GenDecl)
		if !ok || gd.Tok != token.VAR {
			return true
		}

		for _, spec := range gd.Specs {
			vs, ok := spec.(*ast.ValueSpec)
			if !ok || len(vs.Values) != 1 {
				continue
			}

			cl, ok := vs.Values[0].(*ast.CompositeLit)
			if !ok {
				continue
			}

			if arr, ok := cl.Type.(*ast.ArrayType); ok {
				if sel, ok := arr.Elt.(*ast.SelectorExpr); ok &&
					sel.Sel.Name == "Field" {

					start := fset.Position(gd.Pos()).Offset
					end := fset.Position(cl.Rbrace).Offset + 1

					arrowFields = string(src[start:end])
					return false
				}
			}
		}
		return true
	})

	ast.Inspect(file, func(n ast.Node) bool {
		gd, ok := n.(*ast.GenDecl)
		if !ok || gd.Tok != token.TYPE {
			return true
		}

		for _, spec := range gd.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok || ts.Name.Name != sanitizedObjectCaption {
				continue
			}
			if _, ok := ts.Type.(*ast.StructType); !ok {
				continue
			}

			start := fset.Position(gd.Pos()).Offset
			end := fset.Position(ts.End()).Offset
			goStruct = string(src[start:end])
			return false
		}
		return true
	})

	refArrowFields := strings.Replace(arrowFields, fmt.Sprintf("%sFields", sanitizedObjectCaption), fmt.Sprintf("%sRefFields", sanitizedObjectCaption), 1)
	refGoStruct := strings.Replace(goStruct, fmt.Sprintf("%s", sanitizedObjectCaption), fmt.Sprintf("%sRef", sanitizedObjectCaption), 1)

	for refField := range refTree[sanitizedObjectCaption] {
		refArrowFields = regexp.MustCompile(fmt.Sprintf(".*Type: .*%s(Struct|RefStruct).*", refField)).ReplaceAllString(refArrowFields, "")
		refGoStruct = regexp.MustCompile(fmt.Sprintf(".*%s(Ref)?.*", refField)).ReplaceAllString(refGoStruct, "")
	}

	// The replace regex will strip the type declaration from the ref struct, so we need to add it back.
	// Go does not support negative lookaheads.
	if !strings.HasPrefix(refGoStruct, "type") {
		refGoStruct = fmt.Sprintf("type %sRef struct {\n%s", sanitizedObjectCaption, refGoStruct)
	}

	refArrowFields += fmt.Sprintf("\nvar %sRefStruct = arrow.StructOf(%sRefFields...)\n", sanitizedObjectCaption, sanitizedObjectCaption)

	f, err := os.OpenFile(
		filepath,
		os.O_CREATE|os.O_WRONLY|os.O_APPEND,
		0644,
	)
	if err != nil {
		return err
	}
	defer f.Close()

	if _, err := f.Write([]byte(refArrowFields + refGoStruct)); err != nil {
		return err
	}

	cmd := exec.Command("gofmt", "-w", filepath)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to gofmt file %s: %v", filepath, err)
	}

	return nil
}

func sanitizeCaption(caption string) string {
	re := regexp.MustCompile(`[^a-zA-Z0-9]+`)
	return re.ReplaceAllString(caption, "")
}

func removeDeprecatedFields(jsonObjects map[string]interface{}) {
	for objectName := range jsonObjects {
		object := jsonObjects[objectName].(map[string]interface{})
		objectFields := object["attributes"].(map[string]interface{})
		for fieldName := range objectFields {
			fieldValue := objectFields[fieldName].(map[string]interface{})
			if fieldValue["@deprecated"] != nil {
				delete(objectFields, fieldName)
			}
		}
	}
}

// OCSF schema has duplicate fields for some timestamps. These fields have the suffix "_dt".
// We only keep the "time" field.
func removeDTFields(jsonObjects map[string]interface{}) {
	for objectName := range jsonObjects {
		object := jsonObjects[objectName].(map[string]interface{})
		objectFields := object["attributes"].(map[string]interface{})
		for fieldName := range objectFields {
			if strings.HasSuffix(fieldName, "_dt") {
				delete(objectFields, fieldName)
			}
		}
	}
}

func removeProfileFields(objects, profiles map[string]interface{}) {
	for objectName := range objects {
		object := objects[objectName].(map[string]interface{})

		if object["profiles"] == nil {
			continue
		}

		objectProfiles := object["profiles"].([]interface{})
		for _, objectProfileName := range objectProfiles {
			objectProfileName := objectProfileName.(string)
			profile := profiles[objectProfileName].(map[string]interface{})

			objectAttributes := objects[objectName].(map[string]interface{})["attributes"].(map[string]interface{})

			profileFields := profile["attributes"].(map[string]interface{})
			for profileFieldName := range profileFields {
				objectProfileAttr, ok := objectAttributes[profileFieldName]
				if !ok || objectProfileAttr.(map[string]interface{})["requirement"] == "required" {
					continue
				}
				delete(objectAttributes, profileFieldName)
			}
		}
	}
	return
}

func resolveOCSFType(targetType string, types map[string]interface{}) (string, error) {
	if types[targetType] == nil {
		return "", fmt.Errorf("type %s not found", targetType)
	}

	if types[targetType].(map[string]interface{})["type"] != nil {
		ref := types[targetType].(map[string]interface{})["type"].(string)
		return resolveOCSFType(ref, types)
	}

	switch types[targetType].(map[string]interface{})["caption"].(string) {
	case "String":
		return "string", nil
	case "Long":
		return reflect.TypeOf(int64(0)).String(), nil
	case "JSON":
		return "string", nil
	case "Integer":
		return "int32", nil
	case "Float":
		return "float64", nil
	case "Boolean":
		return "bool", nil
	default:
		return "", fmt.Errorf("type %s not supported", targetType)
	}
}

func goTypeToArrowType(targetType string) string {
	var isList bool

	if strings.HasPrefix(targetType, "[]") {
		isList = true
		targetType = strings.TrimPrefix(targetType, "[]")
	}

	if strings.HasPrefix(targetType, "*") {
		targetType = strings.TrimPrefix(targetType, "*")
	}

	switch targetType {
	case "string":
		arrowType := "arrow.BinaryTypes.String"
		if isList {
			return "arrow.ListOf(" + arrowType + ")"
		}
		return arrowType
	case "int32":
		arrowType := "arrow.PrimitiveTypes.Int32"
		if isList {
			return "arrow.ListOf(" + arrowType + ")"
		}
		return arrowType
	case "int64":
		arrowType := "arrow.PrimitiveTypes.Int64"
		if isList {
			return "arrow.ListOf(" + arrowType + ")"
		}
		return arrowType
	case "float64":
		arrowType := "arrow.PrimitiveTypes.Float64"
		if isList {
			return "arrow.ListOf(" + arrowType + ")"
		}
		return arrowType
	case "bool":
		arrowType := "arrow.FixedWidthTypes.Boolean"
		if isList {
			return "arrow.ListOf(" + arrowType + ")"
		}
		return arrowType
	default:
		panic("type " + targetType + " not supported")
	}
}

func sortedKeys(m map[string]interface{}) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}
