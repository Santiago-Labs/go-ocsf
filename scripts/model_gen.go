package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"reflect"
	"regexp"
	"strings"
)

var (
	partitionKeys = map[string][]string{
		"VulnerabilityFinding": {"EventDay"},
	}
)

func main() {
	schemaData, err := os.ReadFile("../ocsf/test_data/schema.json")
	if err != nil {
		log.Fatalf("Failed to read test data: %v", err)
	}

	var schema map[string]interface{}

	err = json.Unmarshal([]byte(schemaData), &schema)
	if err != nil {
		log.Fatalf("Failed to marshal test data: %v", err)
	}

	profiles := schema["profiles"].(map[string]interface{})
	classes := schema["classes"].(map[string]interface{})
	objects := schema["objects"].(map[string]interface{})

	types := schema["types"].(map[string]interface{})

	removeProfileFields(classes, profiles)
	removeDeprecatedFields(objects)
	removeDeprecatedFields(classes)
	removeDTFields(objects)
	removeDTFields(classes)

	for _, class := range classes {
		err := generateGoStruct(class.(map[string]interface{}), objects, types)
		if err != nil {
			log.Fatalf("Failed to generate Go struct: %v", err)
		}
	}

	for _, object := range objects {
		err := generateGoStruct(object.(map[string]interface{}), objects, types)
		if err != nil {
			log.Fatalf("Failed to generate Go struct: %v", err)
		}
	}
}

func generateGoStruct(class, objects, types map[string]interface{}) error {
	classFields, ok := class["attributes"].(map[string]interface{})
	if !ok {
		return nil
	}

	output := fmt.Sprintf(`
// autogenerated by scripts/model_gen.go. DO NOT EDIT
package ocsf

type %s struct {
`, sanitizeCaption(class["caption"].(string)))

	for fieldName := range classFields {
		fieldValue := classFields[fieldName].(map[string]interface{})

		required := fieldValue["requirement"] == "required"
		rawType := fieldValue["type"].(string)

		titleSubstrings := strings.Split(fieldName, "_")
		for idx := range titleSubstrings {
			titleSubstrings[idx] = strings.ToUpper(string(titleSubstrings[idx][0])) + titleSubstrings[idx][1:]
		}

		fieldTitle := strings.Join(titleSubstrings, "")

		var fieldType string
		if strings.HasSuffix(rawType, "_t") {
			var err error
			fieldType, err = resolveOCSFType(rawType, types)
			if err != nil {
				log.Fatalf("Failed to resolve OCSF type: %v", err)
			}
		} else {
			if rawType == "object" {
				fieldType = "string"
			} else {
				fieldType = sanitizeCaption(objects[rawType].(map[string]interface{})["caption"].(string))
			}
		}

		if !required {
			fieldType = "*" + fieldType
		}

		var listTag string
		if fieldValue["is_array"] == true {
			fieldType = "[]" + fieldType
			listTag = ",list"
		}

		if required {
			output += fmt.Sprintf("%s %s `json:\"%s\" parquet:\"%s%s\"`\n", fieldTitle, fieldType, fieldName, fieldName, listTag)
		} else {
			output += fmt.Sprintf("%s %s `json:\"%s,omitempty\" parquet:\"%s,optional%s\"`\n", fieldTitle, fieldType, fieldName, fieldName, listTag)
		}

	}

	output += `}`

	filename := class["name"].(string) + ".go"

	err := os.WriteFile("../ocsf/test/"+filename, []byte(output), 0644)
	if err != nil {
		return err
	}

	cmd := exec.Command("gofmt", "-w", "../ocsf/test/"+filename)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to gofmt file: %v", err)
	}

	return nil
}

func sanitizeCaption(caption string) string {
	re := regexp.MustCompile(`[^a-zA-Z0-9]+`)
	return re.ReplaceAllString(caption, "")
}

func removeDeprecatedFields(jsonObjects map[string]interface{}) {
	for objectName := range jsonObjects {
		object := jsonObjects[objectName].(map[string]interface{})
		objectFields := object["attributes"].(map[string]interface{})
		for fieldName := range objectFields {
			fieldValue := objectFields[fieldName].(map[string]interface{})
			if fieldValue["@deprecated"] != nil {
				delete(objectFields, fieldName)
			}
		}
	}
}

// OCSF schema has duplicate fields for some timestamps. These fields have the suffix "_dt".
// We only keep the "time" field.
func removeDTFields(jsonObjects map[string]interface{}) {
	for objectName := range jsonObjects {
		object := jsonObjects[objectName].(map[string]interface{})
		objectFields := object["attributes"].(map[string]interface{})
		for fieldName := range objectFields {
			if strings.HasSuffix(fieldName, "_dt") {
				delete(objectFields, fieldName)
			}
		}
	}
}

func removeProfileFields(objects, profiles map[string]interface{}) {
	for objectName := range objects {
		object := objects[objectName].(map[string]interface{})

		if object["profiles"] == nil {
			continue
		}

		objectProfiles := object["profiles"].([]interface{})
		for _, objectProfileName := range objectProfiles {
			objectProfileName := objectProfileName.(string)
			profile := profiles[objectProfileName].(map[string]interface{})

			objectAttributes := objects[objectName].(map[string]interface{})["attributes"].(map[string]interface{})

			profileFields := profile["attributes"].(map[string]interface{})
			for profileFieldName := range profileFields {
				delete(objectAttributes, profileFieldName)
			}
		}
	}
	return
}

func resolveOCSFType(targetType string, types map[string]interface{}) (string, error) {
	if types[targetType] == nil {
		return "", fmt.Errorf("type %s not found", targetType)
	}

	if types[targetType].(map[string]interface{})["type"] != nil {
		ref := types[targetType].(map[string]interface{})["type"].(string)
		return resolveOCSFType(ref, types)
	}

	switch types[targetType].(map[string]interface{})["caption"].(string) {
	case "String":
		return "string", nil
	case "Long":
		return reflect.TypeOf(int64(0)).String(), nil
	case "JSON":
		return "string", nil
	case "Integer":
		return "int32", nil
	case "Float":
		return "float64", nil
	case "Boolean":
		return "bool", nil
	default:
		return "", fmt.Errorf("type %s not supported", targetType)
	}
}
